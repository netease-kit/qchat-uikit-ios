// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.2 (swiftlang-5.7.2.135.5 clang-1400.0.29.51)
// swift-module-flags: -target arm64-apple-ios10.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name NECommonKit
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AVFoundation
import CoreGraphics
import Dispatch
import Foundation
import MobileCoreServices
@_exported import NECommonKit
import Photos
import QuartzCore
import Swift
import SystemConfiguration
import UIKit
import _Concurrency
import _StringProcessing
extension Swift.Array {
  public func chunk(_ chunkSize: Swift.Int) -> [[Element]]
}
@propertyWrapper public struct Atomic<Value> {
  public init(wrappedValue value: Value)
  public var wrappedValue: Value {
    get
    set
  }
}
public class CommonLoader<T> where T : AnyObject {
  public init()
  public func localizable(_ key: Swift.String) -> Swift.String
  public func loadImage(_ name: Swift.String) -> UIKit.UIImage?
  public func loadString(source: Swift.String?, type: Swift.String?) -> Swift.String?
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class CommonTool : ObjectiveC.NSObject {
  public static func getCurrentLanguage() -> Swift.String
  @objc override dynamic public init()
  @objc deinit
}
public enum NEAFError : Swift.Error {
  public enum ParameterEncodingFailureReason {
    case missingURL
    case jsonEncodingFailed(error: Swift.Error)
    case propertyListEncodingFailed(error: Swift.Error)
  }
  public enum MultipartEncodingFailureReason {
    case bodyPartURLInvalid(url: Foundation.URL)
    case bodyPartFilenameInvalid(in: Foundation.URL)
    case bodyPartFileNotReachable(at: Foundation.URL)
    case bodyPartFileNotReachableWithError(atURL: Foundation.URL, error: Swift.Error)
    case bodyPartFileIsDirectory(at: Foundation.URL)
    case bodyPartFileSizeNotAvailable(at: Foundation.URL)
    case bodyPartFileSizeQueryFailedWithError(forURL: Foundation.URL, error: Swift.Error)
    case bodyPartInputStreamCreationFailed(for: Foundation.URL)
    case outputStreamCreationFailed(for: Foundation.URL)
    case outputStreamFileAlreadyExists(at: Foundation.URL)
    case outputStreamURLInvalid(url: Foundation.URL)
    case outputStreamWriteFailed(error: Swift.Error)
    case inputStreamReadFailed(error: Swift.Error)
  }
  public enum ResponseValidationFailureReason {
    case dataFileNil
    case dataFileReadFailed(at: Foundation.URL)
    case missingContentType(acceptableContentTypes: [Swift.String])
    case unacceptableContentType(acceptableContentTypes: [Swift.String], responseContentType: Swift.String)
    case unacceptableStatusCode(code: Swift.Int)
  }
  public enum ResponseSerializationFailureReason {
    case inputDataNil
    case inputDataNilOrZeroLength
    case inputFileNil
    case inputFileReadFailed(at: Foundation.URL)
    case stringSerializationFailed(encoding: Swift.String.Encoding)
    case jsonSerializationFailed(error: Swift.Error)
    case propertyListSerializationFailed(error: Swift.Error)
  }
  case invalidURL(url: NECommonKit.URLConvertible)
  case parameterEncodingFailed(reason: NECommonKit.NEAFError.ParameterEncodingFailureReason)
  case multipartEncodingFailed(reason: NECommonKit.NEAFError.MultipartEncodingFailureReason)
  case responseValidationFailed(reason: NECommonKit.NEAFError.ResponseValidationFailureReason)
  case responseSerializationFailed(reason: NECommonKit.NEAFError.ResponseSerializationFailureReason)
}
extension NECommonKit.NEAFError {
  public var isInvalidURLError: Swift.Bool {
    get
  }
  public var isParameterEncodingError: Swift.Bool {
    get
  }
  public var isMultipartEncodingError: Swift.Bool {
    get
  }
  public var isResponseValidationError: Swift.Bool {
    get
  }
  public var isResponseSerializationError: Swift.Bool {
    get
  }
}
extension NECommonKit.NEAFError {
  public var urlConvertible: NECommonKit.URLConvertible? {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var underlyingError: Swift.Error? {
    get
  }
  public var acceptableContentTypes: [Swift.String]? {
    get
  }
  public var responseContentType: Swift.String? {
    get
  }
  public var responseCode: Swift.Int? {
    get
  }
  public var failedStringEncoding: Swift.String.Encoding? {
    get
  }
}
extension NECommonKit.NEAFError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public protocol URLConvertible {
  func asURL() throws -> Foundation.URL
}
extension Swift.String : NECommonKit.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
extension Foundation.URL : NECommonKit.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
extension Foundation.URLComponents : NECommonKit.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
public protocol URLRequestConvertible {
  func asURLRequest() throws -> Foundation.URLRequest
}
extension NECommonKit.URLRequestConvertible {
  public var urlRequest: Foundation.URLRequest? {
    get
  }
}
extension Foundation.URLRequest : NECommonKit.URLRequestConvertible {
  public func asURLRequest() throws -> Foundation.URLRequest
}
extension Foundation.URLRequest {
  public init(url: NECommonKit.URLConvertible, method: NECommonKit.HTTPMethod, headers: NECommonKit.HTTPHeaders? = nil) throws
}
@discardableResult
public func request(_ url: NECommonKit.URLConvertible, method: NECommonKit.HTTPMethod = .get, parameters: NECommonKit.Parameters? = nil, encoding: NECommonKit.ParameterEncoding = URLEncoding.default, headers: NECommonKit.HTTPHeaders? = nil) -> NECommonKit.DataRequest
@discardableResult
public func request(_ urlRequest: NECommonKit.URLRequestConvertible) -> NECommonKit.DataRequest
@discardableResult
public func download(_ url: NECommonKit.URLConvertible, method: NECommonKit.HTTPMethod = .get, parameters: NECommonKit.Parameters? = nil, encoding: NECommonKit.ParameterEncoding = URLEncoding.default, headers: NECommonKit.HTTPHeaders? = nil, to destination: NECommonKit.DownloadRequest.DownloadFileDestination? = nil) -> NECommonKit.DownloadRequest
@discardableResult
public func download(_ urlRequest: NECommonKit.URLRequestConvertible, to destination: NECommonKit.DownloadRequest.DownloadFileDestination? = nil) -> NECommonKit.DownloadRequest
@discardableResult
public func download(resumingWith resumeData: Foundation.Data, to destination: NECommonKit.DownloadRequest.DownloadFileDestination? = nil) -> NECommonKit.DownloadRequest
@discardableResult
public func upload(_ fileURL: Foundation.URL, to url: NECommonKit.URLConvertible, method: NECommonKit.HTTPMethod = .post, headers: NECommonKit.HTTPHeaders? = nil) -> NECommonKit.UploadRequest
@discardableResult
public func upload(_ fileURL: Foundation.URL, with urlRequest: NECommonKit.URLRequestConvertible) -> NECommonKit.UploadRequest
@discardableResult
public func upload(_ data: Foundation.Data, to url: NECommonKit.URLConvertible, method: NECommonKit.HTTPMethod = .post, headers: NECommonKit.HTTPHeaders? = nil) -> NECommonKit.UploadRequest
@discardableResult
public func upload(_ data: Foundation.Data, with urlRequest: NECommonKit.URLRequestConvertible) -> NECommonKit.UploadRequest
@discardableResult
public func upload(_ stream: Foundation.InputStream, to url: NECommonKit.URLConvertible, method: NECommonKit.HTTPMethod = .post, headers: NECommonKit.HTTPHeaders? = nil) -> NECommonKit.UploadRequest
@discardableResult
public func upload(_ stream: Foundation.InputStream, with urlRequest: NECommonKit.URLRequestConvertible) -> NECommonKit.UploadRequest
public func upload(multipartFormData: @escaping (NECommonKit.NEMultipartFormData) -> Swift.Void, usingThreshold encodingMemoryThreshold: Swift.UInt64 = NESessionManager
                     .multipartFormDataEncodingMemoryThreshold, to url: NECommonKit.URLConvertible, method: NECommonKit.HTTPMethod = .post, headers: NECommonKit.HTTPHeaders? = nil, encodingCompletion: ((NECommonKit.NESessionManager.MultipartFormDataEncodingResult) -> Swift.Void)?)
public func upload(multipartFormData: @escaping (NECommonKit.NEMultipartFormData) -> Swift.Void, usingThreshold encodingMemoryThreshold: Swift.UInt64 = NESessionManager
                     .multipartFormDataEncodingMemoryThreshold, with urlRequest: NECommonKit.URLRequestConvertible, encodingCompletion: ((NECommonKit.NESessionManager.MultipartFormDataEncodingResult) -> Swift.Void)?)
@available(iOS 9.0, macOS 10.11, tvOS 9.0, *)
@discardableResult
public func stream(withHostName hostName: Swift.String, port: Swift.Int) -> NECommonKit.StreamRequest
@available(iOS 9.0, macOS 10.11, tvOS 9.0, *)
@discardableResult
public func stream(with netService: Foundation.NetService) -> NECommonKit.StreamRequest
public typealias NEAuthCompletion = (_ granted: Swift.Bool) -> Swift.Void
@_inheritsConvenienceInitializers @objc public class NEAuthManager : ObjectiveC.NSObject {
  @objc public class func hasAudioAuthoriztion() -> Swift.Bool
  @objc public class func requestAudioAuthorization(_ completion: NECommonKit.NEAuthCompletion?)
  @objc public class func hasCameraAuthorization() -> Swift.Bool
  @objc public class func requestCameraAuthorization(_ completion: NECommonKit.NEAuthCompletion?)
  @objc public class func hasPhotoAuthorization() -> Swift.Bool
  public class func requestPhotoAuthorization(_ completion: NECommonKit.NEAuthCompletion?)
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@objc @_Concurrency.MainActor(unsafe) open class NEBarButtonItem : UIKit.UIBarButtonItem {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var tintColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) open func setTarget(_ target: Swift.AnyObject?, action: ObjectiveC.Selector?)
  @objc @_Concurrency.MainActor(unsafe) open var invocation: NECommonKit.NEInvocation?
  @objc deinit
}
public enum ReachabilityStatus {
  case notReachable
  case unknown
  case ethernetOrWiFi
  case wwan
  public static func == (a: NECommonKit.ReachabilityStatus, b: NECommonKit.ReachabilityStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class NEChatDetectNetworkTool {
  public static let shareInstance: NECommonKit.NEChatDetectNetworkTool
  final public let manager: NECommonKit.NENetworkReachabilityManager?
  public func isNetworkRecahability() -> Swift.Bool
  public func netWorkReachability(reachabilityStatus: @escaping (NECommonKit.ReachabilityStatus) -> Swift.Void)
  @objc deinit
}
extension UIKit.UIColor {
  public static let ne_darkText: UIKit.UIColor
  public static let ne_greyText: UIKit.UIColor
  public static let ne_lightText: UIKit.UIColor
  public static let ne_blueText: UIKit.UIColor
  public static let ne_redText: UIKit.UIColor
  public static let ne_disableRedText: UIKit.UIColor
  public static let ne_backcolor: UIKit.UIColor
  public static let ne_emptyTitleColor: UIKit.UIColor
  public static let ne_greenText: UIKit.UIColor
  public static let ne_lightBackgroundColor: UIKit.UIColor
  public static let ne_defautAvatarColor: UIKit.UIColor
  public static let ne_greenColor: UIKit.UIColor
  public static let ne_yellowBackgroundColor: UIKit.UIColor
  public static let ne_borderColor: UIKit.UIColor
  public static let ne_operationBorderColor: UIKit.UIColor
  public static let ne_greyLine: UIKit.UIColor
  public static let ne_redColor: UIKit.UIColor
  public static let ne_backgroundColor: UIKit.UIColor
  public static let ne_navLineColor: UIKit.UIColor
  public static let ne_outlineColor: UIKit.UIColor
  convenience public init(hexString: Swift.String, _ alpha: CoreFoundation.CGFloat = 1.0)
  public var hexString: Swift.String? {
    get
  }
  public class func colorWithNumber(number: Swift.UInt64?) -> UIKit.UIColor
  @objc dynamic public class func colorWithString(string: Swift.String?) -> UIKit.UIColor
}
@objc @_inheritsConvenienceInitializers @objcMembers public class NECommonUtil : ObjectiveC.NSObject {
  @objc public class func getJSONStringFromDictionary(_ dictionary: [Swift.String : Any]) -> Swift.String
  @objc public class func getDictionaryFromJSONString(_ jsonString: Swift.String) -> Foundation.NSDictionary?
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers public class NEConstant : ObjectiveC.NSObject {
  @objc public static let screenWidth: CoreFoundation.CGFloat
  @objc public static let screenHeight: CoreFoundation.CGFloat
  @objc public static let sreenWidthScale: CoreFoundation.CGFloat
  @objc public static let sreenHeightScale: CoreFoundation.CGFloat
  @objc public static let navigationHeight: Swift.Double
  @objc public static let statusBarHeight: CoreFoundation.CGFloat
  @objc public static let navigationAndStatusHeight: Swift.Double
  @objc public static let screenInterval: CoreFoundation.CGFloat
  @objc public static let textFont: (_ fontName: Swift.String, _ fontSize: Swift.Float) -> UIKit.UIFont
  @objc public static let defaultTextFont: (_ fontSize: Swift.Float) -> UIKit.UIFont
  @objc public static let hexRGB: (_ rgbValue: Swift.Int) -> UIKit.UIColor
  @objc public static let hexRGBAlpha: (_ rgbValue: Swift.Int, _ alpha: Swift.Float) -> UIKit.UIColor
  @objc override dynamic public init()
  @objc deinit
}
extension Foundation.Date {
  public static func utcFormattedDate(_ from: Foundation.Date, withDate: Swift.Bool) -> Swift.String
  public static func getFormatPlayTime(_ secounds: Foundation.TimeInterval) -> Swift.String
  public static func getTimeString(_ time: Foundation.TimeInterval) -> Swift.String
  public func isToday() -> Swift.Bool
  public func isThisYear() -> Swift.Bool
}
@available(iOSApplicationExtension, unavailable)
@objc final public class NEInvocation : ObjectiveC.NSObject {
  @objc weak final public var target: Swift.AnyObject?
  @objc final public var action: ObjectiveC.Selector
  @objc public init(_ target: Swift.AnyObject, _ action: ObjectiveC.Selector)
  @objc final public func invoke(from: Any)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOSApplicationExtension, unavailable)
@objc final public class NEKeyboardManager : ObjectiveC.NSObject {
  @objc public static let shared: NECommonKit.NEKeyboardManager
  @objc final public var enable: Swift.Bool {
    @objc get
    @objc set
  }
  @objc final public var keyboardDistanceFromTextField: CoreFoundation.CGFloat
  @objc final public var enableAutoToolbar: Swift.Bool {
    @objc get
    @objc set
  }
  @objc final public var toolbarManageBehaviour: NECommonKit.IQAutoToolbarManageBehaviour
  @objc final public var shouldToolbarUsesTextFieldTintColor: Swift.Bool
  @objc final public var toolbarTintColor: UIKit.UIColor?
  @objc final public var toolbarBarTintColor: UIKit.UIColor?
  @objc final public var previousNextDisplayMode: NECommonKit.IQPreviousNextDisplayMode
  @objc final public var toolbarPreviousBarButtonItemImage: UIKit.UIImage?
  @objc final public var toolbarNextBarButtonItemImage: UIKit.UIImage?
  @objc final public var toolbarDoneBarButtonItemImage: UIKit.UIImage?
  @objc final public var toolbarPreviousBarButtonItemText: Swift.String?
  @objc final public var toolbarPreviousBarButtonItemAccessibilityLabel: Swift.String?
  @objc final public var toolbarNextBarButtonItemText: Swift.String?
  @objc final public var toolbarNextBarButtonItemAccessibilityLabel: Swift.String?
  @objc final public var toolbarDoneBarButtonItemText: Swift.String?
  @objc final public var toolbarDoneBarButtonItemAccessibilityLabel: Swift.String?
  @objc final public var shouldShowToolbarPlaceholder: Swift.Bool
  @objc final public var placeholderFont: UIKit.UIFont?
  @objc final public var placeholderColor: UIKit.UIColor?
  @objc final public var placeholderButtonColor: UIKit.UIColor?
  @objc final public var overrideKeyboardAppearance: Swift.Bool
  @objc final public var keyboardAppearance: UIKit.UIKeyboardAppearance
  @objc final public var shouldResignOnTouchOutside: Swift.Bool {
    @objc get
    @objc set
  }
  @objc final public var resignFirstResponderGesture: UIKit.UITapGestureRecognizer {
    @objc get
    @objc set
  }
  @discardableResult
  @objc final public func resignFirstResponder() -> Swift.Bool
  @objc final public var shouldPlayInputClicks: Swift.Bool
  @objc final public var layoutIfNeededOnUpdate: Swift.Bool
  @objc final public var disabledDistanceHandlingClasses: [UIKit.UIViewController.Type]
  @objc final public var enabledDistanceHandlingClasses: [UIKit.UIViewController.Type]
  @objc final public var disabledToolbarClasses: [UIKit.UIViewController.Type]
  @objc final public var enabledToolbarClasses: [UIKit.UIViewController.Type]
  @objc final public var toolbarPreviousNextAllowedClasses: [UIKit.UIView.Type]
  @objc final public var disabledTouchResignedClasses: [UIKit.UIViewController.Type]
  @objc final public var enabledTouchResignedClasses: [UIKit.UIViewController.Type]
  @objc final public var touchResignedGestureIgnoreClasses: [UIKit.UIView.Type]
  @objc final public func registerTextFieldViewClass(_ aClass: UIKit.UIView.Type, didBeginEditingNotificationName: Swift.String, didEndEditingNotificationName: Swift.String)
  @objc final public func unregisterTextFieldViewClass(_ aClass: UIKit.UIView.Type, didBeginEditingNotificationName: Swift.String, didEndEditingNotificationName: Swift.String)
  @objc deinit
  @objc final public func reloadLayoutIfNeeded()
}
@available(iOSApplicationExtension, unavailable)
extension NECommonKit.NEKeyboardManager : UIKit.UIGestureRecognizerDelegate {
  @_Concurrency.MainActor(unsafe) @objc final public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldReceive touch: UIKit.UITouch) -> Swift.Bool
}
@available(iOSApplicationExtension, unavailable)
extension NECommonKit.NEKeyboardManager {
  @objc final public var enableDebugging: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
  @objc final public func registerAllNotifications()
  @objc final public func unregisterAllNotifications()
  public enum Static {
  }
}
@available(iOSApplicationExtension, unavailable)
extension NECommonKit.NEKeyboardManager {
  @objc final public var movedDistance: CoreFoundation.CGFloat {
    @objc get
  }
  @objc final public var movedDistanceChanged: ((CoreFoundation.CGFloat) -> Swift.Void)? {
    @objc get
    @objc set(newValue)
  }
}
@available(iOSApplicationExtension, unavailable)
extension NECommonKit.NEKeyboardManager {
  @objc final public func reloadInputViews()
}
@available(iOSApplicationExtension, unavailable)
extension NECommonKit.NEKeyboardManager {
  @objc final public var canGoPrevious: Swift.Bool {
    @objc get
  }
  @objc final public var canGoNext: Swift.Bool {
    @objc get
  }
  @discardableResult
  @objc final public func goPrevious() -> Swift.Bool
  @discardableResult
  @objc final public func goNext() -> Swift.Bool
}
@available(iOSApplicationExtension, unavailable)
extension NECommonKit.NEKeyboardManager {
  @objc final public var keyboardShowing: Swift.Bool {
    @objc get
  }
}
@available(iOSApplicationExtension, unavailable)
@objc public enum IQAutoToolbarManageBehaviour : Swift.Int {
  case bySubviews
  case byTag
  case byPosition
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@available(iOSApplicationExtension, unavailable)
@objc public enum IQPreviousNextDisplayMode : Swift.Int {
  case `default`
  case alwaysHide
  case alwaysShow
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@available(iOSApplicationExtension, unavailable)
@objc public enum NEEnableMode : Swift.Int {
  case `default`
  case enabled
  case disabled
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@objc final public class IQKeyboardReturnKeyHandler : ObjectiveC.NSObject {
  @objc weak final public var delegate: (UIKit.UITextFieldDelegate & UIKit.UITextViewDelegate)?
  @objc final public var lastTextFieldReturnKeyType: UIKit.UIReturnKeyType {
    @objc get
    @objc set
  }
  @objc override dynamic public init()
  @objc public init(controller: UIKit.UIViewController)
  @objc deinit
  @objc final public func addTextFieldView(_ view: UIKit.UIView)
  @objc final public func removeTextFieldView(_ view: UIKit.UIView)
  @objc final public func addResponderFromView(_ view: UIKit.UIView)
  @objc final public func removeResponderFromView(_ view: UIKit.UIView)
}
@available(iOSApplicationExtension, unavailable)
extension NECommonKit.IQKeyboardReturnKeyHandler : UIKit.UITextFieldDelegate {
  @_Concurrency.MainActor(unsafe) @objc final public func textFieldShouldBeginEditing(_ textField: UIKit.UITextField) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func textFieldShouldEndEditing(_ textField: UIKit.UITextField) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func textFieldDidBeginEditing(_ textField: UIKit.UITextField)
  @_Concurrency.MainActor(unsafe) @objc final public func textFieldDidEndEditing(_ textField: UIKit.UITextField)
  @available(iOS 10.0, *)
  @_Concurrency.MainActor(unsafe) @objc final public func textFieldDidEndEditing(_ textField: UIKit.UITextField, reason: UIKit.UITextField.DidEndEditingReason)
  @_Concurrency.MainActor(unsafe) @objc final public func textField(_ textField: UIKit.UITextField, shouldChangeCharactersIn range: Foundation.NSRange, replacementString string: Swift.String) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func textFieldShouldClear(_ textField: UIKit.UITextField) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func textFieldShouldReturn(_ textField: UIKit.UITextField) -> Swift.Bool
}
@available(iOSApplicationExtension, unavailable)
extension NECommonKit.IQKeyboardReturnKeyHandler : UIKit.UITextViewDelegate {
  @_Concurrency.MainActor(unsafe) @objc final public func textViewShouldBeginEditing(_ textView: UIKit.UITextView) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func textViewShouldEndEditing(_ textView: UIKit.UITextView) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func textViewDidBeginEditing(_ textView: UIKit.UITextView)
  @_Concurrency.MainActor(unsafe) @objc final public func textViewDidEndEditing(_ textView: UIKit.UITextView)
  @_Concurrency.MainActor(unsafe) @objc final public func textView(_ textView: UIKit.UITextView, shouldChangeTextIn range: Foundation.NSRange, replacementText text: Swift.String) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func textViewDidChange(_ textView: UIKit.UITextView)
  @_Concurrency.MainActor(unsafe) @objc final public func textViewDidChangeSelection(_ textView: UIKit.UITextView)
  @available(iOS 10.0, *)
  @_Concurrency.MainActor(unsafe) @objc final public func textView(_ aTextView: UIKit.UITextView, shouldInteractWith URL: Foundation.URL, in characterRange: Foundation.NSRange, interaction: UIKit.UITextItemInteraction) -> Swift.Bool
  @available(iOS 10.0, *)
  @_Concurrency.MainActor(unsafe) @objc final public func textView(_ aTextView: UIKit.UITextView, shouldInteractWith textAttachment: UIKit.NSTextAttachment, in characterRange: Foundation.NSRange, interaction: UIKit.UITextItemInteraction) -> Swift.Bool
  @available(iOS, deprecated: 10.0)
  @_Concurrency.MainActor(unsafe) @objc final public func textView(_ aTextView: UIKit.UITextView, shouldInteractWith URL: Foundation.URL, in characterRange: Foundation.NSRange) -> Swift.Bool
  @available(iOS, deprecated: 10.0)
  @_Concurrency.MainActor(unsafe) @objc final public func textView(_ aTextView: UIKit.UITextView, shouldInteractWith textAttachment: UIKit.NSTextAttachment, in characterRange: Foundation.NSRange) -> Swift.Bool
}
open class NEMultipartFormData {
  open var contentType: Swift.String {
    get
    set
  }
  public var contentLength: Swift.UInt64 {
    get
  }
  public var boundary: Swift.String
  public init()
  public func append(_ data: Foundation.Data, withName name: Swift.String)
  public func append(_ data: Foundation.Data, withName name: Swift.String, mimeType: Swift.String)
  public func append(_ data: Foundation.Data, withName name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ fileURL: Foundation.URL, withName name: Swift.String)
  public func append(_ fileURL: Foundation.URL, withName name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ stream: Foundation.InputStream, withLength length: Swift.UInt64, name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ stream: Foundation.InputStream, withLength length: Swift.UInt64, headers: NECommonKit.HTTPHeaders)
  public func encode() throws -> Foundation.Data
  public func writeEncodedData(to fileURL: Foundation.URL) throws
  @objc deinit
}
@_hasMissingDesignatedInitializers open class NENetworkReachabilityManager {
  public enum NetworkReachabilityStatus {
    case unknown
    case notReachable
    case reachable(NECommonKit.NENetworkReachabilityManager.ConnectionType)
  }
  public enum ConnectionType {
    case ethernetOrWiFi
    case wwan
    public static func == (a: NECommonKit.NENetworkReachabilityManager.ConnectionType, b: NECommonKit.NENetworkReachabilityManager.ConnectionType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public typealias Listener = (NECommonKit.NENetworkReachabilityManager.NetworkReachabilityStatus) -> Swift.Void
  open var isReachable: Swift.Bool {
    get
  }
  open var isReachableOnWWAN: Swift.Bool {
    get
  }
  open var isReachableOnEthernetOrWiFi: Swift.Bool {
    get
  }
  open var networkReachabilityStatus: NECommonKit.NENetworkReachabilityManager.NetworkReachabilityStatus {
    get
  }
  open var listenerQueue: Dispatch.DispatchQueue
  open var listener: NECommonKit.NENetworkReachabilityManager.Listener?
  open var flags: SystemConfiguration.SCNetworkReachabilityFlags? {
    get
  }
  open var previousFlags: SystemConfiguration.SCNetworkReachabilityFlags
  convenience public init?(host: Swift.String)
  convenience public init?()
  @objc deinit
  @discardableResult
  open func startListening() -> Swift.Bool
  open func stopListening()
}
extension NECommonKit.NENetworkReachabilityManager.NetworkReachabilityStatus : Swift.Equatable {
}
public func == (lhs: NECommonKit.NENetworkReachabilityManager.NetworkReachabilityStatus, rhs: NECommonKit.NENetworkReachabilityManager.NetworkReachabilityStatus) -> Swift.Bool
extension ObjectiveC.NSObject {
  public class func className() -> Swift.String
  public func className() -> Swift.String
}
@_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@objc @_Concurrency.MainActor(unsafe) open class NEPreviousNextView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public protocol RequestAdapter {
  func adapt(_ urlRequest: Foundation.URLRequest) throws -> Foundation.URLRequest
}
public typealias RequestRetryCompletion = (_ shouldRetry: Swift.Bool, _ timeDelay: Foundation.TimeInterval) -> Swift.Void
public protocol RequestRetrier {
  func should(_ manager: NECommonKit.NESessionManager, retry request: NECommonKit.NERequest, with error: Swift.Error, completion: @escaping NECommonKit.RequestRetryCompletion)
}
public typealias HTTPHeaders = [Swift.String : Swift.String]
@_hasMissingDesignatedInitializers open class NERequest {
  public typealias ProgressHandler = (Foundation.Progress) -> Swift.Void
  open var delegate: NECommonKit.NETaskDelegate {
    get
  }
  open var task: Foundation.URLSessionTask? {
    get
  }
  final public let session: Foundation.URLSession
  open var request: Foundation.URLRequest? {
    get
  }
  open var response: Foundation.HTTPURLResponse? {
    get
  }
  open var retryCount: Swift.UInt {
    get
  }
  @discardableResult
  open func authenticate(user: Swift.String, password: Swift.String, persistence: Foundation.URLCredential.Persistence = .forSession) -> Self
  @discardableResult
  open func authenticate(usingCredential credential: Foundation.URLCredential) -> Self
  open class func authorizationHeader(user: Swift.String, password: Swift.String) -> (key: Swift.String, value: Swift.String)?
  open func resume()
  open func suspend()
  open func cancel()
  @objc deinit
}
extension NECommonKit.NERequest : Swift.CustomStringConvertible {
  open var description: Swift.String {
    get
  }
}
extension NECommonKit.NERequest : Swift.CustomDebugStringConvertible {
  open var debugDescription: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers open class DataRequest : NECommonKit.NERequest {
  override open var request: Foundation.URLRequest? {
    get
  }
  open var progress: Foundation.Progress {
    get
  }
  @discardableResult
  open func stream(closure: ((Foundation.Data) -> Swift.Void)? = nil) -> Self
  @discardableResult
  open func downloadProgress(queue: Dispatch.DispatchQueue = DispatchQueue.main, closure: @escaping NECommonKit.DataRequest.ProgressHandler) -> Self
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers open class DownloadRequest : NECommonKit.NERequest {
  public struct DownloadOptions : Swift.OptionSet {
    public let rawValue: Swift.UInt
    public static let createIntermediateDirectories: NECommonKit.DownloadRequest.DownloadOptions
    public static let removePreviousFile: NECommonKit.DownloadRequest.DownloadOptions
    public init(rawValue: Swift.UInt)
    public typealias ArrayLiteralElement = NECommonKit.DownloadRequest.DownloadOptions
    public typealias Element = NECommonKit.DownloadRequest.DownloadOptions
    public typealias RawValue = Swift.UInt
  }
  public typealias DownloadFileDestination = (_ temporaryURL: Foundation.URL, _ response: Foundation.HTTPURLResponse) -> (destinationURL: Foundation.URL, options: NECommonKit.DownloadRequest.DownloadOptions)
  override open var request: Foundation.URLRequest? {
    get
  }
  open var resumeData: Foundation.Data? {
    get
  }
  open var progress: Foundation.Progress {
    get
  }
  override open func cancel()
  open func cancel(createResumeData: Swift.Bool)
  @discardableResult
  open func downloadProgress(queue: Dispatch.DispatchQueue = DispatchQueue.main, closure: @escaping NECommonKit.DownloadRequest.ProgressHandler) -> Self
  open class func suggestedDownloadDestination(for directory: Foundation.FileManager.SearchPathDirectory = .documentDirectory, in domain: Foundation.FileManager.SearchPathDomainMask = .userDomainMask) -> NECommonKit.DownloadRequest.DownloadFileDestination
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers open class UploadRequest : NECommonKit.DataRequest {
  override open var request: Foundation.URLRequest? {
    get
  }
  open var uploadProgress: Foundation.Progress {
    get
  }
  @discardableResult
  open func uploadProgress(queue: Dispatch.DispatchQueue = DispatchQueue.main, closure: @escaping NECommonKit.UploadRequest.ProgressHandler) -> Self
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 9.0, macOS 10.11, tvOS 9.0, *)
open class StreamRequest : NECommonKit.NERequest {
  @objc deinit
}
public struct NEDefaultDataResponse {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let data: Foundation.Data?
  public let error: Swift.Error?
  public let timeline: NECommonKit.NETimeline
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?, timeline: NECommonKit.NETimeline = NETimeline(), metrics: Swift.AnyObject? = nil)
}
public struct DataResponse<Value> {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let data: Foundation.Data?
  public let result: NECommonKit.NEResult<Value>
  public let timeline: NECommonKit.NETimeline
  public var value: Value? {
    get
  }
  public var error: Swift.Error? {
    get
  }
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, result: NECommonKit.NEResult<Value>, timeline: NECommonKit.NETimeline = NETimeline())
}
extension NECommonKit.DataResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension NECommonKit.DataResponse {
  public func map<T>(_ transform: (Value) -> T) -> NECommonKit.DataResponse<T>
  public func flatMap<T>(_ transform: (Value) throws -> T) -> NECommonKit.DataResponse<T>
  public func mapError<E>(_ transform: (Swift.Error) -> E) -> NECommonKit.DataResponse<Value> where E : Swift.Error
  public func flatMapError<E>(_ transform: (Swift.Error) throws -> E) -> NECommonKit.DataResponse<Value> where E : Swift.Error
}
public struct DefaultDownloadResponse {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let temporaryURL: Foundation.URL?
  public let destinationURL: Foundation.URL?
  public let resumeData: Foundation.Data?
  public let error: Swift.Error?
  public let timeline: NECommonKit.NETimeline
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, temporaryURL: Foundation.URL?, destinationURL: Foundation.URL?, resumeData: Foundation.Data?, error: Swift.Error?, timeline: NECommonKit.NETimeline = NETimeline(), metrics: Swift.AnyObject? = nil)
}
public struct DownloadResponse<Value> {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let temporaryURL: Foundation.URL?
  public let destinationURL: Foundation.URL?
  public let resumeData: Foundation.Data?
  public let result: NECommonKit.NEResult<Value>
  public let timeline: NECommonKit.NETimeline
  public var value: Value? {
    get
  }
  public var error: Swift.Error? {
    get
  }
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, temporaryURL: Foundation.URL?, destinationURL: Foundation.URL?, resumeData: Foundation.Data?, result: NECommonKit.NEResult<Value>, timeline: NECommonKit.NETimeline = NETimeline())
}
extension NECommonKit.DownloadResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension NECommonKit.DownloadResponse {
  public func map<T>(_ transform: (Value) -> T) -> NECommonKit.DownloadResponse<T>
  public func flatMap<T>(_ transform: (Value) throws -> T) -> NECommonKit.DownloadResponse<T>
  public func mapError<E>(_ transform: (Swift.Error) -> E) -> NECommonKit.DownloadResponse<Value> where E : Swift.Error
  public func flatMapError<E>(_ transform: (Swift.Error) throws -> E) -> NECommonKit.DownloadResponse<Value> where E : Swift.Error
}
@available(iOS 10.0, macOS 10.12, tvOS 10.0, *)
extension NECommonKit.NEDefaultDataResponse {
  public var metrics: Foundation.URLSessionTaskMetrics? {
    get
  }
}
@available(iOS 10.0, macOS 10.12, tvOS 10.0, *)
extension NECommonKit.DataResponse {
  public var metrics: Foundation.URLSessionTaskMetrics? {
    get
  }
}
@available(iOS 10.0, macOS 10.12, tvOS 10.0, *)
extension NECommonKit.DefaultDownloadResponse {
  public var metrics: Foundation.URLSessionTaskMetrics? {
    get
  }
}
@available(iOS 10.0, macOS 10.12, tvOS 10.0, *)
extension NECommonKit.DownloadResponse {
  public var metrics: Foundation.URLSessionTaskMetrics? {
    get
  }
}
public protocol DataResponseSerializerProtocol {
  associatedtype SerializedObject
  var serializeResponse: (Foundation.URLRequest?, Foundation.HTTPURLResponse?, Foundation.Data?, Swift.Error?) -> NECommonKit.NEResult<Self.SerializedObject> { get }
}
public struct DataResponseSerializer<Value> : NECommonKit.DataResponseSerializerProtocol {
  public typealias SerializedObject = Value
  public var serializeResponse: (Foundation.URLRequest?, Foundation.HTTPURLResponse?, Foundation.Data?, Swift.Error?) -> NECommonKit.NEResult<Value>
  public init(serializeResponse: @escaping (Foundation.URLRequest?, Foundation.HTTPURLResponse?, Foundation.Data?, Swift.Error?) -> NECommonKit.NEResult<Value>)
}
public protocol DownloadResponseSerializerProtocol {
  associatedtype SerializedObject
  var serializeResponse: (Foundation.URLRequest?, Foundation.HTTPURLResponse?, Foundation.URL?, Swift.Error?) -> NECommonKit.NEResult<Self.SerializedObject> { get }
}
public struct DownloadResponseSerializer<Value> : NECommonKit.DownloadResponseSerializerProtocol {
  public typealias SerializedObject = Value
  public var serializeResponse: (Foundation.URLRequest?, Foundation.HTTPURLResponse?, Foundation.URL?, Swift.Error?) -> NECommonKit.NEResult<Value>
  public init(serializeResponse: @escaping (Foundation.URLRequest?, Foundation.HTTPURLResponse?, Foundation.URL?, Swift.Error?) -> NECommonKit.NEResult<Value>)
}
extension NECommonKit.DataRequest {
  @discardableResult
  public func response(queue: Dispatch.DispatchQueue? = nil, completionHandler: @escaping (NECommonKit.NEDefaultDataResponse) -> Swift.Void) -> Self
  @discardableResult
  public func response<T>(queue: Dispatch.DispatchQueue? = nil, responseSerializer: T, completionHandler: @escaping (NECommonKit.DataResponse<T.SerializedObject>) -> Swift.Void) -> Self where T : NECommonKit.DataResponseSerializerProtocol
}
extension NECommonKit.DownloadRequest {
  @discardableResult
  public func response(queue: Dispatch.DispatchQueue? = nil, completionHandler: @escaping (NECommonKit.DefaultDownloadResponse) -> Swift.Void) -> Self
  @discardableResult
  public func response<T>(queue: Dispatch.DispatchQueue? = nil, responseSerializer: T, completionHandler: @escaping (NECommonKit.DownloadResponse<T.SerializedObject>) -> Swift.Void) -> Self where T : NECommonKit.DownloadResponseSerializerProtocol
}
extension NECommonKit.NERequest {
  public static func serializeResponseData(response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) -> NECommonKit.NEResult<Foundation.Data>
}
extension NECommonKit.DataRequest {
  public static func dataResponseSerializer() -> NECommonKit.DataResponseSerializer<Foundation.Data>
  @discardableResult
  public func responseData(queue: Dispatch.DispatchQueue? = nil, completionHandler: @escaping (NECommonKit.DataResponse<Foundation.Data>) -> Swift.Void) -> Self
}
extension NECommonKit.DownloadRequest {
  public static func dataResponseSerializer() -> NECommonKit.DownloadResponseSerializer<Foundation.Data>
  @discardableResult
  public func responseData(queue: Dispatch.DispatchQueue? = nil, completionHandler: @escaping (NECommonKit.DownloadResponse<Foundation.Data>) -> Swift.Void) -> Self
}
extension NECommonKit.NERequest {
  public static func serializeResponseString(encoding: Swift.String.Encoding?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) -> NECommonKit.NEResult<Swift.String>
}
extension NECommonKit.DataRequest {
  public static func stringResponseSerializer(encoding: Swift.String.Encoding? = nil) -> NECommonKit.DataResponseSerializer<Swift.String>
  @discardableResult
  public func responseString(queue: Dispatch.DispatchQueue? = nil, encoding: Swift.String.Encoding? = nil, completionHandler: @escaping (NECommonKit.DataResponse<Swift.String>) -> Swift.Void) -> Self
}
extension NECommonKit.DownloadRequest {
  public static func stringResponseSerializer(encoding: Swift.String.Encoding? = nil) -> NECommonKit.DownloadResponseSerializer<Swift.String>
  @discardableResult
  public func responseString(queue: Dispatch.DispatchQueue? = nil, encoding: Swift.String.Encoding? = nil, completionHandler: @escaping (NECommonKit.DownloadResponse<Swift.String>) -> Swift.Void) -> Self
}
extension NECommonKit.NERequest {
  public static func serializeResponseJSON(options: Foundation.JSONSerialization.ReadingOptions, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) -> NECommonKit.NEResult<Any>
}
extension NECommonKit.DataRequest {
  public static func jsonResponseSerializer(options: Foundation.JSONSerialization.ReadingOptions = .allowFragments) -> NECommonKit.DataResponseSerializer<Any>
  @discardableResult
  public func responseJSON(queue: Dispatch.DispatchQueue? = nil, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments, completionHandler: @escaping (NECommonKit.DataResponse<Any>) -> Swift.Void) -> Self
}
extension NECommonKit.DownloadRequest {
  public static func jsonResponseSerializer(options: Foundation.JSONSerialization.ReadingOptions = .allowFragments) -> NECommonKit.DownloadResponseSerializer<Any>
  @discardableResult
  public func responseJSON(queue: Dispatch.DispatchQueue? = nil, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments, completionHandler: @escaping (NECommonKit.DownloadResponse<Any>) -> Swift.Void) -> Self
}
extension NECommonKit.NERequest {
  public static func serializeResponsePropertyList(options: Foundation.PropertyListSerialization.ReadOptions, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) -> NECommonKit.NEResult<Any>
}
extension NECommonKit.DataRequest {
  public static func propertyListResponseSerializer(options: Foundation.PropertyListSerialization.ReadOptions = []) -> NECommonKit.DataResponseSerializer<Any>
  @discardableResult
  public func responsePropertyList(queue: Dispatch.DispatchQueue? = nil, options: Foundation.PropertyListSerialization.ReadOptions = [], completionHandler: @escaping (NECommonKit.DataResponse<Any>) -> Swift.Void) -> Self
}
extension NECommonKit.DownloadRequest {
  public static func propertyListResponseSerializer(options: Foundation.PropertyListSerialization.ReadOptions = []) -> NECommonKit.DownloadResponseSerializer<Any>
  @discardableResult
  public func responsePropertyList(queue: Dispatch.DispatchQueue? = nil, options: Foundation.PropertyListSerialization.ReadOptions = [], completionHandler: @escaping (NECommonKit.DownloadResponse<Any>) -> Swift.Void) -> Self
}
public enum NEResult<Value> {
  case success(Value)
  case failure(Swift.Error)
  public var isSuccess: Swift.Bool {
    get
  }
  public var isFailure: Swift.Bool {
    get
  }
  public var value: Value? {
    get
  }
  public var error: Swift.Error? {
    get
  }
}
extension Swift.Result : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension NECommonKit.NEResult : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension NECommonKit.NEResult {
  public init(value: () throws -> Value)
  public func unwrap() throws -> Value
  public func map<T>(_ transform: (Value) -> T) -> NECommonKit.NEResult<T>
  public func flatMap<T>(_ transform: (Value) throws -> T) -> NECommonKit.NEResult<T>
  public func mapError<T>(_ transform: (Swift.Error) -> T) -> NECommonKit.NEResult<Value> where T : Swift.Error
  public func flatMapError<T>(_ transform: (Swift.Error) throws -> T) -> NECommonKit.NEResult<Value> where T : Swift.Error
  @discardableResult
  public func withValue(_ closure: (Value) throws -> Swift.Void) rethrows -> NECommonKit.NEResult<Value>
  @discardableResult
  public func withError(_ closure: (Swift.Error) throws -> Swift.Void) rethrows -> NECommonKit.NEResult<Value>
  @discardableResult
  public func ifSuccess(_ closure: () throws -> Swift.Void) rethrows -> NECommonKit.NEResult<Value>
  @discardableResult
  public func ifFailure(_ closure: () throws -> Swift.Void) rethrows -> NECommonKit.NEResult<Value>
}
open class NEServerTrustPolicyManager {
  final public let policies: [Swift.String : NECommonKit.ServerTrustPolicy]
  public init(policies: [Swift.String : NECommonKit.ServerTrustPolicy])
  open func serverTrustPolicy(forHost host: Swift.String) -> NECommonKit.ServerTrustPolicy?
  @objc deinit
}
public enum ServerTrustPolicy {
  case performDefaultEvaluation(validateHost: Swift.Bool)
  case performRevokedEvaluation(validateHost: Swift.Bool, revocationFlags: CoreFoundation.CFOptionFlags)
  case pinCertificates(certificates: [Security.SecCertificate], validateCertificateChain: Swift.Bool, validateHost: Swift.Bool)
  case pinPublicKeys(publicKeys: [Security.SecKey], validateCertificateChain: Swift.Bool, validateHost: Swift.Bool)
  case disableEvaluation
  case customEvaluation((_ serverTrust: Security.SecTrust, _ host: Swift.String) -> Swift.Bool)
  public static func certificates(in bundle: Foundation.Bundle = Bundle.main) -> [Security.SecCertificate]
  public static func publicKeys(in bundle: Foundation.Bundle = Bundle.main) -> [Security.SecKey]
  public func evaluate(_ serverTrust: Security.SecTrust, forHost host: Swift.String) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers open class NESessionDelegate : ObjectiveC.NSObject {
  open var sessionDidBecomeInvalidWithError: ((Foundation.URLSession, Swift.Error?) -> Swift.Void)?
  open var sessionDidReceiveChallenge: ((Foundation.URLSession, Foundation.URLAuthenticationChallenge) -> (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?))?
  open var sessionDidReceiveChallengeWithCompletion: ((Foundation.URLSession, Foundation.URLAuthenticationChallenge, @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void) -> Swift.Void)?
  open var sessionDidFinishEventsForBackgroundURLSession: ((Foundation.URLSession) -> Swift.Void)?
  open var taskWillPerformHTTPRedirection: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.HTTPURLResponse, Foundation.URLRequest) -> Foundation.URLRequest?)?
  open var taskWillPerformHTTPRedirectionWithCompletion: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.HTTPURLResponse, Foundation.URLRequest, @escaping (Foundation.URLRequest?) -> Swift.Void) -> Swift.Void)?
  open var taskDidReceiveChallenge: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.URLAuthenticationChallenge) -> (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?))?
  open var taskDidReceiveChallengeWithCompletion: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.URLAuthenticationChallenge, @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void) -> Swift.Void)?
  open var taskNeedNewBodyStream: ((Foundation.URLSession, Foundation.URLSessionTask) -> Foundation.InputStream?)?
  open var taskNeedNewBodyStreamWithCompletion: ((Foundation.URLSession, Foundation.URLSessionTask, @escaping (Foundation.InputStream?) -> Swift.Void) -> Swift.Void)?
  open var taskDidSendBodyData: ((Foundation.URLSession, Foundation.URLSessionTask, Swift.Int64, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var taskDidComplete: ((Foundation.URLSession, Foundation.URLSessionTask, Swift.Error?) -> Swift.Void)?
  open var dataTaskDidReceiveResponse: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.URLResponse) -> Foundation.URLSession.ResponseDisposition)?
  open var dataTaskDidReceiveResponseWithCompletion: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.URLResponse, @escaping (Foundation.URLSession.ResponseDisposition) -> Swift.Void) -> Swift.Void)?
  open var dataTaskDidBecomeDownloadTask: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.URLSessionDownloadTask) -> Swift.Void)?
  open var dataTaskDidReceiveData: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.Data) -> Swift.Void)?
  open var dataTaskWillCacheResponse: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Foundation.CachedURLResponse?)?
  open var dataTaskWillCacheResponseWithCompletion: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.CachedURLResponse, @escaping (Foundation.CachedURLResponse?) -> Swift.Void) -> Swift.Void)?
  open var downloadTaskDidFinishDownloadingToURL: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Foundation.URL) -> Swift.Void)?
  open var downloadTaskDidWriteData: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Swift.Int64, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var downloadTaskDidResumeAtOffset: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Swift.Int64, Swift.Int64) -> Swift.Void)?
  @available(iOS 9.0, macOS 10.11, tvOS 9.0, *)
  open var streamTaskReadClosed: ((Foundation.URLSession, Foundation.URLSessionStreamTask) -> Swift.Void)? {
    get
    set
  }
  @available(iOS 9.0, macOS 10.11, tvOS 9.0, *)
  open var streamTaskWriteClosed: ((Foundation.URLSession, Foundation.URLSessionStreamTask) -> Swift.Void)? {
    get
    set
  }
  @available(iOS 9.0, macOS 10.11, tvOS 9.0, *)
  open var streamTaskBetterRouteDiscovered: ((Foundation.URLSession, Foundation.URLSessionStreamTask) -> Swift.Void)? {
    get
    set
  }
  @available(iOS 9.0, macOS 10.11, tvOS 9.0, *)
  open var streamTaskDidBecomeInputAndOutputStreams: ((Foundation.URLSession, Foundation.URLSessionStreamTask, Foundation.InputStream, Foundation.OutputStream) -> Swift.Void)? {
    get
    set
  }
  open subscript(task: Foundation.URLSessionTask) -> NECommonKit.NERequest? {
    get
    set
  }
  @objc override dynamic public init()
  @objc override dynamic open func responds(to selector: ObjectiveC.Selector) -> Swift.Bool
  @objc deinit
}
extension NECommonKit.NESessionDelegate : Foundation.URLSessionDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic open func urlSessionDidFinishEvents(forBackgroundURLSession session: Foundation.URLSession)
}
extension NECommonKit.NESessionDelegate : Foundation.URLSessionTaskDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, needNewBodyStream completionHandler: @escaping (Foundation.InputStream?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  @available(iOS 10.0, macOS 10.12, tvOS 10.0, *)
  @objc(URLSession:task:didFinishCollectingMetrics:) dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
}
extension NECommonKit.NESessionDelegate : Foundation.URLSessionDataDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive response: Foundation.URLResponse, completionHandler: @escaping (Foundation.URLSession.ResponseDisposition) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didBecome downloadTask: Foundation.URLSessionDownloadTask)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse, completionHandler: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
extension NECommonKit.NESessionDelegate : Foundation.URLSessionDownloadDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
}
@available(iOS 9.0, macOS 10.11, tvOS 9.0, *)
extension NECommonKit.NESessionDelegate : Foundation.URLSessionStreamDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, readClosedFor streamTask: Foundation.URLSessionStreamTask)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, writeClosedFor streamTask: Foundation.URLSessionStreamTask)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, betterRouteDiscoveredFor streamTask: Foundation.URLSessionStreamTask)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, streamTask: Foundation.URLSessionStreamTask, didBecome inputStream: Foundation.InputStream, outputStream: Foundation.OutputStream)
}
open class NESessionManager {
  public enum MultipartFormDataEncodingResult {
    case success(request: NECommonKit.UploadRequest, streamingFromDisk: Swift.Bool, streamFileURL: Foundation.URL?)
    case failure(Swift.Error)
  }
  public static let `default`: NECommonKit.NESessionManager
  public static let defaultHTTPHeaders: NECommonKit.HTTPHeaders
  public static let multipartFormDataEncodingMemoryThreshold: Swift.UInt64
  final public let session: Foundation.URLSession
  final public let delegate: NECommonKit.NESessionDelegate
  open var startRequestsImmediately: Swift.Bool
  open var adapter: NECommonKit.RequestAdapter?
  open var retrier: NECommonKit.RequestRetrier? {
    get
    set
  }
  open var backgroundCompletionHandler: (() -> Swift.Void)?
  public init(configuration: Foundation.URLSessionConfiguration = URLSessionConfiguration.default, delegate: NECommonKit.NESessionDelegate = NESessionDelegate(), serverTrustPolicyManager: NECommonKit.NEServerTrustPolicyManager? = nil)
  public init?(session: Foundation.URLSession, delegate: NECommonKit.NESessionDelegate, serverTrustPolicyManager: NECommonKit.NEServerTrustPolicyManager? = nil)
  @objc deinit
  @discardableResult
  open func request(_ url: NECommonKit.URLConvertible, method: NECommonKit.HTTPMethod = .get, parameters: NECommonKit.Parameters? = nil, encoding: NECommonKit.ParameterEncoding = URLEncoding.default, headers: NECommonKit.HTTPHeaders? = nil) -> NECommonKit.DataRequest
  @discardableResult
  open func request(_ urlRequest: NECommonKit.URLRequestConvertible) -> NECommonKit.DataRequest
  @discardableResult
  open func download(_ url: NECommonKit.URLConvertible, method: NECommonKit.HTTPMethod = .get, parameters: NECommonKit.Parameters? = nil, encoding: NECommonKit.ParameterEncoding = URLEncoding.default, headers: NECommonKit.HTTPHeaders? = nil, to destination: NECommonKit.DownloadRequest.DownloadFileDestination? = nil) -> NECommonKit.DownloadRequest
  @discardableResult
  open func download(_ urlRequest: NECommonKit.URLRequestConvertible, to destination: NECommonKit.DownloadRequest.DownloadFileDestination? = nil) -> NECommonKit.DownloadRequest
  @discardableResult
  open func download(resumingWith resumeData: Foundation.Data, to destination: NECommonKit.DownloadRequest.DownloadFileDestination? = nil) -> NECommonKit.DownloadRequest
  @discardableResult
  open func upload(_ fileURL: Foundation.URL, to url: NECommonKit.URLConvertible, method: NECommonKit.HTTPMethod = .post, headers: NECommonKit.HTTPHeaders? = nil) -> NECommonKit.UploadRequest
  @discardableResult
  open func upload(_ fileURL: Foundation.URL, with urlRequest: NECommonKit.URLRequestConvertible) -> NECommonKit.UploadRequest
  @discardableResult
  open func upload(_ data: Foundation.Data, to url: NECommonKit.URLConvertible, method: NECommonKit.HTTPMethod = .post, headers: NECommonKit.HTTPHeaders? = nil) -> NECommonKit.UploadRequest
  @discardableResult
  open func upload(_ data: Foundation.Data, with urlRequest: NECommonKit.URLRequestConvertible) -> NECommonKit.UploadRequest
  @discardableResult
  open func upload(_ stream: Foundation.InputStream, to url: NECommonKit.URLConvertible, method: NECommonKit.HTTPMethod = .post, headers: NECommonKit.HTTPHeaders? = nil) -> NECommonKit.UploadRequest
  @discardableResult
  open func upload(_ stream: Foundation.InputStream, with urlRequest: NECommonKit.URLRequestConvertible) -> NECommonKit.UploadRequest
  open func upload(multipartFormData: @escaping (NECommonKit.NEMultipartFormData) -> Swift.Void, usingThreshold encodingMemoryThreshold: Swift.UInt64 = NESessionManager
                     .multipartFormDataEncodingMemoryThreshold, to url: NECommonKit.URLConvertible, method: NECommonKit.HTTPMethod = .post, headers: NECommonKit.HTTPHeaders? = nil, queue: Dispatch.DispatchQueue? = nil, encodingCompletion: ((NECommonKit.NESessionManager.MultipartFormDataEncodingResult) -> Swift.Void)?)
  open func upload(multipartFormData: @escaping (NECommonKit.NEMultipartFormData) -> Swift.Void, usingThreshold encodingMemoryThreshold: Swift.UInt64 = NESessionManager
                     .multipartFormDataEncodingMemoryThreshold, with urlRequest: NECommonKit.URLRequestConvertible, queue: Dispatch.DispatchQueue? = nil, encodingCompletion: ((NECommonKit.NESessionManager.MultipartFormDataEncodingResult) -> Swift.Void)?)
  @available(iOS 9.0, macOS 10.11, tvOS 9.0, *)
  @discardableResult
  open func stream(withHostName hostName: Swift.String, port: Swift.Int) -> NECommonKit.StreamRequest
  @available(iOS 9.0, macOS 10.11, tvOS 9.0, *)
  @discardableResult
  open func stream(with netService: Foundation.NetService) -> NECommonKit.StreamRequest
}
extension Swift.String {
  public func finalSize(_ font: UIKit.UIFont, _ size: CoreFoundation.CGSize, _ lines: Swift.Int = 0) -> CoreFoundation.CGSize
}
extension Foundation.NSAttributedString {
  public func finalSize(_ font: UIKit.UIFont, _ size: CoreFoundation.CGSize, _ lines: Swift.Int = 0) -> CoreFoundation.CGSize
}
extension Swift.String {
  public func findAllIndex(_ string: Swift.String) -> [Foundation.NSRange]
  public static func stringFromDate(date: Foundation.Date) -> Swift.String
  public static func firstDayInYear() -> Foundation.Date?
  public static func stringFromDictionary(dictionary: [Swift.String : Any]) -> Swift.String?
  public static func dictionaryFromString(string: Swift.String) -> [Swift.String : Any]?
}
@objc @_hasMissingDesignatedInitializers open class NETaskDelegate : ObjectiveC.NSObject {
  final public let queue: Foundation.OperationQueue
  public var data: Foundation.Data? {
    get
  }
  public var error: Swift.Error?
  @objc deinit
}
@_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@objc @_Concurrency.MainActor(unsafe) open class NETextView : UIKit.UITextView {
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect, textContainer: UIKit.NSTextContainer?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func awakeFromNib()
  @objc deinit
  @_Concurrency.MainActor(unsafe) public var placeholderLabel: UIKit.UILabel {
    get
    set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var placeholderTextColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var placeholder: Swift.String? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) open var attributedPlaceholder: Foundation.NSAttributedString? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var text: Swift.String! {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var attributedText: Foundation.NSAttributedString! {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var font: UIKit.UIFont? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var textAlignment: UIKit.NSTextAlignment {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override weak dynamic open var delegate: UIKit.UITextViewDelegate? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
}
public struct NETimeline {
  public let requestStartTime: CoreFoundation.CFAbsoluteTime
  public let initialResponseTime: CoreFoundation.CFAbsoluteTime
  public let requestCompletedTime: CoreFoundation.CFAbsoluteTime
  public let serializationCompletedTime: CoreFoundation.CFAbsoluteTime
  public let latency: Foundation.TimeInterval
  public let requestDuration: Foundation.TimeInterval
  public let serializationDuration: Foundation.TimeInterval
  public let totalDuration: Foundation.TimeInterval
  public init(requestStartTime: CoreFoundation.CFAbsoluteTime = 0.0, initialResponseTime: CoreFoundation.CFAbsoluteTime = 0.0, requestCompletedTime: CoreFoundation.CFAbsoluteTime = 0.0, serializationCompletedTime: CoreFoundation.CFAbsoluteTime = 0.0)
}
extension NECommonKit.NETimeline : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension NECommonKit.NETimeline : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOSApplicationExtension, unavailable)
@_Concurrency.MainActor(unsafe) open class NETitleBarButtonItem : NECommonKit.NEBarButtonItem {
  @objc @_Concurrency.MainActor(unsafe) open var titleFont: UIKit.UIFont? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var title: Swift.String? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) open var titleColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) open var selectableTitleColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override open var invocation: NECommonKit.NEInvocation? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) convenience public init(title: Swift.String?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOSApplicationExtension, unavailable)
@objc @_Concurrency.MainActor(unsafe) open class NEToolbar : UIKit.UIToolbar, UIKit.UIInputViewAudioFeedback {
  @objc @_Concurrency.MainActor(unsafe) open var previousBarButton: NECommonKit.NEBarButtonItem {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) open var nextBarButton: NECommonKit.NEBarButtonItem {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) open var titleBarButton: NECommonKit.NETitleBarButtonItem {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) open var doneBarButton: NECommonKit.NEBarButtonItem {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) open var fixedSpaceBarButton: NECommonKit.NEBarButtonItem {
    @objc get
    @objc set(newValue)
  }
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func sizeThatFits(_ size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var tintColor: UIKit.UIColor! {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc open var enableInputClicksWhenVisible: Swift.Bool {
    @objc get
  }
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
@objc extension UIKit.UIScrollView {
  @objc @_Concurrency.MainActor(unsafe) dynamic public var shouldIgnoreScrollingAdjustment: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public var shouldIgnoreContentInsetAdjustment: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public var shouldRestoreScrollViewContentOffset: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
}
@available(iOSApplicationExtension, unavailable)
public let kNEUseDefaultKeyboardDistance: CoreFoundation.CGFloat
@available(iOSApplicationExtension, unavailable)
@objc extension UIKit.UIView {
  @objc @_Concurrency.MainActor(unsafe) dynamic public var keyboardDistanceFromTextField: CoreFoundation.CGFloat {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public var ignoreSwitchingByNextPrevious: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public var enableMode: NECommonKit.NEEnableMode {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public var shouldResignOnTouchOutsideMode: NECommonKit.NEEnableMode {
    @objc get
    @objc set(newValue)
  }
}
@available(iOSApplicationExtension, unavailable)
@objc extension UIKit.UIView {
  @objc @_Concurrency.MainActor(unsafe) dynamic public func viewContainingController() -> UIKit.UIViewController?
  @objc @_Concurrency.MainActor(unsafe) dynamic public func topMostController() -> UIKit.UIViewController?
  @objc @_Concurrency.MainActor(unsafe) dynamic public func parentContainerViewController() -> UIKit.UIViewController?
  @objc @_Concurrency.MainActor(unsafe) dynamic public func superviewOfClassType(_ classType: UIKit.UIView.Type, belowView: UIKit.UIView? = nil) -> UIKit.UIView?
}
@available(iOSApplicationExtension, unavailable)
@objc final public class NEBarButtonItemConfiguration : ObjectiveC.NSObject {
  @objc public init(barButtonSystemItem: UIKit.UIBarButtonItem.SystemItem, action: ObjectiveC.Selector)
  @objc public init(image: UIKit.UIImage, action: ObjectiveC.Selector)
  @objc public init(title: Swift.String, action: ObjectiveC.Selector)
  final public let barButtonSystemItem: UIKit.UIBarButtonItem.SystemItem?
  @objc final public let image: UIKit.UIImage?
  @objc final public let title: Swift.String?
  @objc final public let action: ObjectiveC.Selector?
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
@objc extension UIKit.UIImage {
  @objc public static func keyboardLeftImage() -> UIKit.UIImage?
  @objc public static func keyboardRightImage() -> UIKit.UIImage?
  @objc public static func keyboardUpImage() -> UIKit.UIImage?
  @objc public static func keyboardDownImage() -> UIKit.UIImage?
  @objc public static func keyboardPreviousImage() -> UIKit.UIImage?
  @objc public static func keyboardNextImage() -> UIKit.UIImage?
}
@available(iOSApplicationExtension, unavailable)
@objc extension UIKit.UIView {
  @objc @_Concurrency.MainActor(unsafe) dynamic public var keyboardToolbar: NECommonKit.NEToolbar {
    @objc get
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public var shouldHideToolbarPlaceholder: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public var toolbarPlaceholder: Swift.String? {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public var drawingToolbarPlaceholder: Swift.String? {
    @objc get
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addKeyboardToolbarWithTarget(target: Swift.AnyObject?, titleText: Swift.String?, rightBarButtonConfiguration: NECommonKit.NEBarButtonItemConfiguration?, previousBarButtonConfiguration: NECommonKit.NEBarButtonItemConfiguration? = nil, nextBarButtonConfiguration: NECommonKit.NEBarButtonItemConfiguration? = nil)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addDoneOnKeyboardWithTarget(_ target: Swift.AnyObject?, action: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addDoneOnKeyboardWithTarget(_ target: Swift.AnyObject?, action: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addRightButtonOnKeyboardWithImage(_ image: UIKit.UIImage, target: Swift.AnyObject?, action: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addRightButtonOnKeyboardWithImage(_ image: UIKit.UIImage, target: Swift.AnyObject?, action: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addRightButtonOnKeyboardWithText(_ text: Swift.String, target: Swift.AnyObject?, action: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addRightButtonOnKeyboardWithText(_ text: Swift.String, target: Swift.AnyObject?, action: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addCancelDoneOnKeyboardWithTarget(_ target: Swift.AnyObject?, cancelAction: ObjectiveC.Selector, doneAction: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addRightLeftOnKeyboardWithTarget(_ target: Swift.AnyObject?, leftButtonTitle: Swift.String, rightButtonTitle: Swift.String, leftButtonAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addRightLeftOnKeyboardWithTarget(_ target: Swift.AnyObject?, leftButtonImage: UIKit.UIImage, rightButtonImage: UIKit.UIImage, leftButtonAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addCancelDoneOnKeyboardWithTarget(_ target: Swift.AnyObject?, cancelAction: ObjectiveC.Selector, doneAction: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addRightLeftOnKeyboardWithTarget(_ target: Swift.AnyObject?, leftButtonTitle: Swift.String, rightButtonTitle: Swift.String, leftButtonAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addRightLeftOnKeyboardWithTarget(_ target: Swift.AnyObject?, leftButtonImage: UIKit.UIImage, rightButtonImage: UIKit.UIImage, leftButtonAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addPreviousNextDoneOnKeyboardWithTarget(_ target: Swift.AnyObject?, previousAction: ObjectiveC.Selector, nextAction: ObjectiveC.Selector, doneAction: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addPreviousNextRightOnKeyboardWithTarget(_ target: Swift.AnyObject?, rightButtonImage: UIKit.UIImage, previousAction: ObjectiveC.Selector, nextAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addPreviousNextRightOnKeyboardWithTarget(_ target: Swift.AnyObject?, rightButtonTitle: Swift.String, previousAction: ObjectiveC.Selector, nextAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addPreviousNextDoneOnKeyboardWithTarget(_ target: Swift.AnyObject?, previousAction: ObjectiveC.Selector, nextAction: ObjectiveC.Selector, doneAction: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addPreviousNextRightOnKeyboardWithTarget(_ target: Swift.AnyObject?, rightButtonImage: UIKit.UIImage, previousAction: ObjectiveC.Selector, nextAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addPreviousNextRightOnKeyboardWithTarget(_ target: Swift.AnyObject?, rightButtonTitle: Swift.String, previousAction: ObjectiveC.Selector, nextAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, titleText: Swift.String?)
}
@available(iOSApplicationExtension, unavailable)
@objc extension UIKit.UIViewController {
  @objc @_Concurrency.MainActor(unsafe) dynamic open func parentNEContainerViewController() -> UIKit.UIViewController?
  @objc @available(*, deprecated, message: "Due to change in core-logic of handling distance between textField and keyboard distance, this layout contraint tweak is no longer needed and things will just work out of the box regardless of constraint pinned with safeArea/layoutGuide/superview.")
  @IBOutlet @_Concurrency.MainActor(unsafe) dynamic public var NELayoutGuideConstraint: UIKit.NSLayoutConstraint? {
    @objc get
    @objc set(newValue)
  }
}
extension Foundation.NSNotification.Name {
  public enum Task {
    public static let DidResume: Foundation.Notification.Name
    public static let DidSuspend: Foundation.Notification.Name
    public static let DidCancel: Foundation.Notification.Name
    public static let DidComplete: Foundation.Notification.Name
  }
}
extension Foundation.Notification {
  public enum Key {
    public static let Task: Swift.String
    public static let ResponseData: Swift.String
  }
}
public enum HTTPMethod : Swift.String {
  case options
  case get
  case head
  case post
  case put
  case patch
  case delete
  case trace
  case connect
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public typealias Parameters = [Swift.String : Any]
public protocol ParameterEncoding {
  func encode(_ urlRequest: NECommonKit.URLRequestConvertible, with parameters: NECommonKit.Parameters?) throws -> Foundation.URLRequest
}
public struct URLEncoding : NECommonKit.ParameterEncoding {
  public enum Destination {
    case methodDependent, queryString, httpBody
    public static func == (a: NECommonKit.URLEncoding.Destination, b: NECommonKit.URLEncoding.Destination) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum ArrayEncoding {
    case brackets, noBrackets
    public static func == (a: NECommonKit.URLEncoding.ArrayEncoding, b: NECommonKit.URLEncoding.ArrayEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum BoolEncoding {
    case numeric, literal
    public static func == (a: NECommonKit.URLEncoding.BoolEncoding, b: NECommonKit.URLEncoding.BoolEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var `default`: NECommonKit.URLEncoding {
    get
  }
  public static var methodDependent: NECommonKit.URLEncoding {
    get
  }
  public static var queryString: NECommonKit.URLEncoding {
    get
  }
  public static var httpBody: NECommonKit.URLEncoding {
    get
  }
  public let destination: NECommonKit.URLEncoding.Destination
  public let arrayEncoding: NECommonKit.URLEncoding.ArrayEncoding
  public let boolEncoding: NECommonKit.URLEncoding.BoolEncoding
  public init(destination: NECommonKit.URLEncoding.Destination = .methodDependent, arrayEncoding: NECommonKit.URLEncoding.ArrayEncoding = .brackets, boolEncoding: NECommonKit.URLEncoding.BoolEncoding = .numeric)
  public func encode(_ urlRequest: NECommonKit.URLRequestConvertible, with parameters: NECommonKit.Parameters?) throws -> Foundation.URLRequest
  public func queryComponents(fromKey key: Swift.String, value: Any) -> [(Swift.String, Swift.String)]
  public func escape(_ string: Swift.String) -> Swift.String
}
public struct JSONEncoding : NECommonKit.ParameterEncoding {
  public static var `default`: NECommonKit.JSONEncoding {
    get
  }
  public static var prettyPrinted: NECommonKit.JSONEncoding {
    get
  }
  public let options: Foundation.JSONSerialization.WritingOptions
  public init(options: Foundation.JSONSerialization.WritingOptions = [])
  public func encode(_ urlRequest: NECommonKit.URLRequestConvertible, with parameters: NECommonKit.Parameters?) throws -> Foundation.URLRequest
  public func encode(_ urlRequest: NECommonKit.URLRequestConvertible, withJSONObject jsonObject: Any? = nil) throws -> Foundation.URLRequest
}
public struct PropertyListEncoding : NECommonKit.ParameterEncoding {
  public static var `default`: NECommonKit.PropertyListEncoding {
    get
  }
  public static var xml: NECommonKit.PropertyListEncoding {
    get
  }
  public static var binary: NECommonKit.PropertyListEncoding {
    get
  }
  public let format: Foundation.PropertyListSerialization.PropertyListFormat
  public let options: Foundation.PropertyListSerialization.WriteOptions
  public init(format: Foundation.PropertyListSerialization.PropertyListFormat = .xml, options: Foundation.PropertyListSerialization.WriteOptions = 0)
  public func encode(_ urlRequest: NECommonKit.URLRequestConvertible, with parameters: NECommonKit.Parameters?) throws -> Foundation.URLRequest
}
extension NECommonKit.NERequest {
  public enum ValidationResult {
    case success
    case failure(Swift.Error)
  }
}
extension NECommonKit.DataRequest {
  public typealias Validation = (Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.Data?) -> NECommonKit.NERequest.ValidationResult
  @discardableResult
  public func validate(_ validation: @escaping NECommonKit.DataRequest.Validation) -> Self
  @discardableResult
  public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  public func validate<S>(contentType acceptableContentTypes: S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  public func validate() -> Self
}
extension NECommonKit.DownloadRequest {
  public typealias Validation = (_ request: Foundation.URLRequest?, _ response: Foundation.HTTPURLResponse, _ temporaryURL: Foundation.URL?, _ destinationURL: Foundation.URL?) -> NECommonKit.NERequest.ValidationResult
  @discardableResult
  public func validate(_ validation: @escaping NECommonKit.DownloadRequest.Validation) -> Self
  @discardableResult
  public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  public func validate<S>(contentType acceptableContentTypes: S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  public func validate() -> Self
}
extension NECommonKit.ReachabilityStatus : Swift.Equatable {}
extension NECommonKit.ReachabilityStatus : Swift.Hashable {}
@available(iOSApplicationExtension, unavailable)
extension NECommonKit.IQAutoToolbarManageBehaviour : Swift.Equatable {}
@available(iOSApplicationExtension, unavailable)
extension NECommonKit.IQAutoToolbarManageBehaviour : Swift.Hashable {}
@available(iOSApplicationExtension, unavailable)
extension NECommonKit.IQAutoToolbarManageBehaviour : Swift.RawRepresentable {}
@available(iOSApplicationExtension, unavailable)
extension NECommonKit.IQPreviousNextDisplayMode : Swift.Equatable {}
@available(iOSApplicationExtension, unavailable)
extension NECommonKit.IQPreviousNextDisplayMode : Swift.Hashable {}
@available(iOSApplicationExtension, unavailable)
extension NECommonKit.IQPreviousNextDisplayMode : Swift.RawRepresentable {}
@available(iOSApplicationExtension, unavailable)
extension NECommonKit.NEEnableMode : Swift.Equatable {}
@available(iOSApplicationExtension, unavailable)
extension NECommonKit.NEEnableMode : Swift.Hashable {}
@available(iOSApplicationExtension, unavailable)
extension NECommonKit.NEEnableMode : Swift.RawRepresentable {}
extension NECommonKit.NENetworkReachabilityManager.ConnectionType : Swift.Equatable {}
extension NECommonKit.NENetworkReachabilityManager.ConnectionType : Swift.Hashable {}
extension NECommonKit.HTTPMethod : Swift.Equatable {}
extension NECommonKit.HTTPMethod : Swift.Hashable {}
extension NECommonKit.HTTPMethod : Swift.RawRepresentable {}
extension NECommonKit.URLEncoding.Destination : Swift.Equatable {}
extension NECommonKit.URLEncoding.Destination : Swift.Hashable {}
extension NECommonKit.URLEncoding.ArrayEncoding : Swift.Equatable {}
extension NECommonKit.URLEncoding.ArrayEncoding : Swift.Hashable {}
extension NECommonKit.URLEncoding.BoolEncoding : Swift.Equatable {}
extension NECommonKit.URLEncoding.BoolEncoding : Swift.Hashable {}
